# Шаблоны расписания для круговых турниров

## Обзор

Для круговых турниров существует несколько стандартных алгоритмов составления расписания, каждый из которых имеет свои преимущества в зависимости от целей турнира.

## Реализованные шаблоны

### 1. Алгоритм Бергера (Berger) - по умолчанию
**Описание:** Классический алгоритм круговой ротации с фиксированной позицией и вращением остальных участников.

**Преимущества:**
- Справедливое распределение нагрузки
- Сбалансированное чередование "дома/гостей"
- Стандарт для профессиональных турниров

**Когда использовать:**
- Официальные турниры
- Когда важна максимальная справедливость
- Группы от 4 участников

**Параметры:**
- `balance_home_away`: балансировка порядка команд (по умолчанию `true`)

---

### 2. Змейка (Snake)
**Описание:** Последовательное составление пар: 1-2, 3-4, 5-6, затем 1-3, 2-4, 5-6 и т.д.

**Преимущества:**
- Простой для понимания
- Легко планировать вручную
- Быстрая генерация

**Когда использовать:**
- Небольшие группы (3-6 участников)
- Неформальные турниры
- Когда нужна простота

**Недостатки:**
- Менее сбалансирован для больших групп
- Возможны неравномерные перерывы между играми

---

### 3. Случайный (Random)
**Описание:** Все матчи распределяются случайным образом по турам.

**Преимущества:**
- Непредсказуемость
- Разнообразие

**Когда использовать:**
- Тренировочные турниры
- Развлекательные мероприятия
- Когда справедливость не критична

**Недостатки:**
- Может быть несбалансированным
- Не подходит для официальных турниров

**Параметры:**
- `seed`: зерно для воспроизводимости (опционально)

---

### 4. Оптимизированный по кортам (Court-Optimized)
**Описание:** Минимизирует простой между играми одной команды, учитывая количество доступных кортов.

**Преимущества:**
- Минимальное время ожидания
- Эффективное использование кортов
- Команды играют с минимальными перерывами

**Когда использовать:**
- Ограниченное количество кортов
- Плотный график турнира
- Когда важна скорость проведения

**Параметры:**
- `courts_count`: количество доступных кортов (обязательно)
- `min_rest_games`: минимум игр отдыха между матчами команды (по умолчанию 1)

---

### 5. Сбалансированный отдых (Balanced Rest)
**Описание:** Максимизирует и выравнивает время отдыха между играми каждой команды.

**Преимущества:**
- Равномерная нагрузка
- Достаточный отдых между матчами
- Снижение риска травм

**Когда использовать:**
- Физически требовательные форматы
- Длинные матчи (3+ сета)
- Турниры на несколько дней

**Параметры:**
- `min_rest_rounds`: минимум туров отдыха между матчами (по умолчанию 2)

---

## Сравнительная таблица

| Шаблон | Справедливость | Простота | Скорость | Отдых | Рекомендуется для |
|--------|---------------|----------|----------|-------|-------------------|
| Бергер | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | Официальные турниры |
| Змейка | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐ | Небольшие группы |
| Случайный | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐ | Неформальные турниры |
| По кортам | ⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐ | Ограниченные корты |
| Отдых | ⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐⭐ | Длинные матчи |

---

## Технические детали

### Модель данных

```python
class SchedulePattern(models.Model):
    """Шаблон расписания для круговых турниров"""
    
    class PatternType(models.TextChoices):
        BERGER = 'berger', 'Алгоритм Бергера'
        SNAKE = 'snake', 'Змейка'
        RANDOM = 'random', 'Случайный'
        COURT_OPTIMIZED = 'court_optimized', 'Оптимизированный по кортам'
        BALANCED_REST = 'balanced_rest', 'Сбалансированный отдых'
    
    name = models.CharField(max_length=100)
    pattern_type = models.CharField(max_length=20, choices=PatternType.choices)
    description = models.TextField()
    is_default = models.BooleanField(default=False)
    parameters = models.JSONField(default=dict)  # Дополнительные параметры
```

### Добавление в Tournament

```python
class Tournament(models.Model):
    # ... существующие поля ...
    schedule_pattern = models.ForeignKey(
        SchedulePattern, 
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        help_text="Шаблон расписания для круговой системы"
    )
```

---

## UX: Выбор шаблона

### 1. При создании турнира
- Выпадающий список с шаблонами
- Краткое описание каждого шаблона
- Иконка рекомендации для стандартных сценариев
- Параметры шаблона (если есть)

### 2. На странице турнира
- Кнопка "Сгенерировать расписание" (если матчей нет)
- Кнопка "Пересоздать расписание" (если матчи не начаты)
- Модальное окно с выбором шаблона и параметров
- Предупреждение при пересоздании

### 3. Визуализация
- Отображение текущего шаблона в заголовке расписания
- Подсказка с описанием выбранного шаблона

---

## Примеры использования

### Пример 1: Официальный турнир
```
Шаблон: Алгоритм Бергера
Участников: 8
Туров: 7
Матчей в туре: 4
Особенности: Сбалансированное чередование порядка
```

### Пример 2: Быстрый турнир на 2 кортах
```
Шаблон: Оптимизированный по кортам
Участников: 6
Кортов: 2
Туров: ~8 (с учетом параллельных игр)
Особенности: Минимальное время ожидания
```

### Пример 3: Марафон на выносливость
```
Шаблон: Сбалансированный отдых
Участников: 6
Минимум отдыха: 2 тура
Туров: 5
Особенности: Между играми каждой команды минимум 2 тура отдыха
```

---

---

### 6. Кастомный шаблон (Custom)
**Описание:** Пользовательский шаблон с ручным заданием порядка пар по турам для конкретного количества участников.

**Преимущества:**
- Полный контроль над расписанием
- Можно учесть специфику конкретного турнира
- Возможность создания библиотеки проверенных шаблонов

**Когда использовать:**
- Специфические требования к порядку игр
- Повторяющиеся турниры с одинаковым форматом
- Когда стандартные алгоритмы не подходят

**Формат данных:**
```json
{
  "participants_count": 4,
  "rounds": [
    {"round": 1, "pairs": [[1, 3], [2, 4]]},
    {"round": 2, "pairs": [[1, 4], [2, 3]]},
    {"round": 3, "pairs": [[1, 2], [3, 4]]}
  ]
}
```

**Пример использования:**
- Участников: 4
- Тур 1: 1-3, 2-4
- Тур 2: 1-4, 2-3
- Тур 3: 1-2, 3-4

**Валидация:**
- Каждый участник играет с каждым ровно 1 раз
- Участник не играет сам с собой
- В каждом туре участник играет максимум 1 матч

---

## Будущие улучшения

1. **Гибридные шаблоны**: комбинация нескольких алгоритмов
2. **Учет предпочтений**: приоритет определенных пар в начале/конце
3. **Временные слоты**: привязка к конкретному времени
4. **Экспорт расписания**: в календарь, PDF, Excel
5. **Статистика шаблонов**: анализ эффективности разных подходов
6. **Редактор кастомных шаблонов**: визуальный интерфейс для создания своих шаблонов

---

## Актуальная логика выбора формата в UI

- При открытии модального окна выбора формата для группы клиент запрашивает шаблоны по количеству участников N: `GET /api/schedule-patterns/by_participants/?count=N&system=round_robin`.
- Если N нечетное, дополнительно запрашиваются шаблоны для N+1 и оба списка объединяются. Далее применяется фильтр:
  - системные шаблоны (`is_system=true`) всегда отображаются;
  - кастомные шаблоны — при четном N берутся только с `participants_count=N`, при нечетном N — только `participants_count=N+1`.
- Список сортируется по алфавиту по полю `name`.
- Текущий установленный формат определяется из `tournaments_tournament.group_schedule_patterns` по ключу вида `"Группа X"` и:
  - выводится в шапке модального окна как «Текущий формат: …»;
  - автоматически выделяется в списке (радио-выбор).

## Совместимость со старыми турнирами

- Если `group_schedule_patterns` пусто/`{}`/`"{}"`, по умолчанию используется «Алгоритм Бергера».
- Сериализатор турнира (`TournamentSerializer`) всегда возвращает `group_schedule_patterns` как JSON‑объект (dict); если в БД хранится строка, она безопасно парсится.

## Генерация матчей и нумерация

- При фиксации участников (POST `/api/tournaments/{id}/lock_participants/`) создаются матчи групп с нумерацией `order_in_round`:
  - Тур 1: 1, 2, …
  - Тур 2: 101, 102, …
  - Тур k: `(k-1)*100 + i`, где `i` — номер пары в туре с 1.
- Для каждого матча заполняются поля:
  - `stage = 'group'`
  - `group_index = X` (номер группы)
  - `round_index = k` (номер тура)
  - `round_name = 'Группа X'`
  - `team_low_id`, `team_high_id` — нормализованная пара для уникальности
  - `team_1_id`, `team_2_id` — фактический порядок для UI
